---
title: 安全框架之Spring Security
date: 2024-04-22 22:29:15
permalink: /micro-service-ecology/SpringSecurity/
categories: 
  - 微服务生态
  - 安全框架
tags: 
  - null
author: 
  name: bombax
  link: https://github.com/coderofmutou
---
## SpringSecurity框架简介

### 概要
- Spring 是非常流行和成功的 Java 应用开发框架，SpringSecurity 正是 Spring 家族中的成员。SpringSecurity 基于 Spring 框架，提供了一套 Web 应用安全性的完整解决方案。
- 正如你可能知道的关于安全方面的两个主要区域是“**认证**”和“**授权**”（或者访问控制），一般来说，Web 应用的安全性包括 **用户认证(Authentication)和用户授权(Authorization)** 两个部分，这两点也是 SpringSecurity 重要核心功能。
   - 用户认证指的是验证某个用户是否为系统中的合法主体，也就是说用户能否访问该系统。用户认证一般要求用户提供用户名和密码。系统通过校验用户名和密码来完成认证过程。**通俗点说就是系统认为用户是否能登录**。
   - 用户授权指的是验证某个用户是否有权限执行某个操作。在一个系统中，不同用户所具有的权限是不同的。比如对一个文件来说，有的用户只能进行读取，而有的用户可以进行修改。一般来说，系统会为不同的用户分配不同的角色，而每个角色则对应一系列的权限。**通俗点讲就是系统判断用户是否有权限去做某些事情。**

Spring Security 是一个框架，提供针对常见攻击的身份验证，授权和保护。通过对命令式和反应式应用程序的一流支持，它是保护基于 Spring 的应用程序的事实标准。

### 同款产品对比
#### [Spring Security](https://spring.io/projects/spring-security)
Spring 技术栈的组成部分。通过提供完整可扩展的认证和授权支持保护你的应用程序。
特点：
1. 和 Spring 无缝整合。
2. 全面的权限控制。
3. 专门为 Web 开发而设计。
4. 旧版本不能脱离 Web 环境使用。
5. 新版本对整个框架进行了分层抽取，分成了核心模块和 Web 模块。单独引入核心模块就可以脱离 Web 环境。
6. 重量级。

#### Shiro
Apache 旗下的轻量级权限控制框架。
特点：
1. 轻量级。Shiro 主张的理念是把复杂的事情变简单。针对对性能有更高要求的互联网应用有更好表现。
2. 通用性。
3. 好处：不局限于 Web 环境，可以脱离 Web 环境使用。
4. 缺陷：在 Web 环境下一些特定的需求需要手动编写代码定制。

### 总结
- Spring Security 是 Spring 家族中的一个安全管理框架，实际上，在 Spring Boot 出现之前，Spring Security 就已经发展了多年了，但是使用的并不多，安全管理这个领域，一直是 Shiro 的天下。
- 相对于 Shiro，在 SSM 中整合 Spring Security 都是比较麻烦的操作，所以，Spring Security 虽然功能比 Shiro 强大，但是使用反而没有 Shiro 多（Shiro 虽然功能没有 Spring Security 多，但是对于大部分项目而言，Shiro 也够用了）。
- 自从有了 Spring Boot 之后，Spring Boot 对于 Spring Security 提供了自动化配置方案，可以使用更少的配置来使用 Spring Security。
- 因此，一般来说，常见的安全管理技术栈的组合是这样的：
   - SSM + Shiro
   - Spring Boot/Spring Cloud + Spring Security

以上只是一个推荐的组合而已，如果单纯从技术上来说，无论怎么组合，都是可以运行的。

### 项目模块划分
在 Spring Security 3.0 中，代码库被细分为单独的 jar，它们更清楚地区分不同的功能区域和第三方依赖项。如

#### Core - spring-security-core .jar
包含核心身份验证和 access-contol 类和接口，远程支持和基本配置 API。任何使用 Spring Security 的应用程序都需要。支持独立应用程序，远程客户端，方法（服务层）安全性和 JDBC 用户配置。包含顶级包：

- `org.springframework.security.core`
- `org.springframework.security.access`
- `org.springframework.security.authentication`
- `org.springframework.security.provisioning`

#### Remoting - spring-security-remoting.jar
提供与 Spring Remoting 的整合。除非正在编写使用 Spring 远程处理的远程客户端，否则不需要此操作。主要包是`org.springframework.security.remoting`。

#### Web - spring-security-web.jar
包含过滤器和相关的 web - 安全基础结构代码。任何具有 servlet API 依赖性的东西。如果您需要 Spring Security web 身份验证服务和基于 URL 的访问控制，则需要它。主要包是`org.springframework.security.web`。

#### Config - spring-security-config .jar
包含安全名称空间解析代码和 Java 配置代码。如果您使用 Spring Security XML 命名空间进行配置或 Spring Security 的 Java 配置支持，则需要它。主要包是`org.springframework.security.config`。这些类都不打算直接用于应用程序。

#### LDAP - spring-security-ldap.jar
LDAP 身份验证和配置代码。如果需要使用 LDAP 身份验证或管理 LDAP 用户条目，则为必需。顶级包是`org.springframework.security.ldap`。

#### OAuth 2.0 Core - spring-security-oauth2-core.jar
spring-security-oauth2-core.jar 包含为_OAuth 2.0 授权框架_和_OpenID Connect Core 1.0_提供支持的核心类和接口。使用_OAuth 2.0_或_OpenID Connect Core 1.0_的应用程序（例如客户端，资源服务器和授权服务器）需要它。顶级包是`org.springframework.security.oauth2.core`。

#### OAuth 2.0 Client - spring-security-oauth2-client.jar
spring-security-oauth2-client.jar 是 Spring Security 对_OAuth 2.0 授权框架_和_OpenID Connect Core 1.0_的客户端支持。应用程序需要利用**OAuth 2.0登录**和/或 OAuth 客户端支持。顶级包是`org.springframework.security.oauth2.client`。

#### OAuth 2.0 JOSE - spring-security-oauth2-jose.jar
spring-security-oauth2-jose.jar 包含 Spring Security 对_JOSE_（Javascript 对象签名和加密）框架的支持。JOSE 旨在提供安全地传输双方之间的权利要求的方法。它由一系列规范构建：

-  JSON Web 令牌(JWT) 
-  JSON Web 签名(JWS) 
-  JSON Web 加密(JWE) 
-  JSON Web 密钥(JWK) 

它包含顶级包：

- `org.springframework.security.oauth2.jwt`
- `org.springframework.security.oauth2.jose`

#### ACL - spring-security-acl.jar
专门的域对象 ACL 实现。用于将安全性应用于应用程序中的特定域对象实例。顶级包是`org.springframework.security.acls`。

#### CAS - spring-security-cas .jar
Spring Security CAS 客户端集成。如果要对 CAS 单点登录服务器使用 Spring Security web 身份验证。顶级包是`org.springframework.security.cas`。

#### OpenID - spring-security-openid .jar
OpenID web 身份验证支持。用于针对外部 OpenID 服务器对用户进行身份验证。`org.springframework.security.openid`.需要 OpenID4Java。

#### Test - spring-security-test.jar
支持使用 Spring Security 进行测试。

### 权限管理中的相关概念
#### 主体
英文单词：principal
使用系统的用户或设备或从其他系统远程登录的用户等等。简单说就是谁使用系统谁就是主体。

#### 认证
英文单词：authentication
权限管理系统确认一个主体的身份，允许主体进入系统。简单说就是“主体”证明自己是谁。
笼统的认为就是以前所做的登录操作。

#### 授权
英文单词：authorization
将操作系统的“权力”“授予”“主体”，这样主体就具备了操作系统中特定功能的能力。
所以简单来说，授权就是给用户分配权限。

### 获取Spring Security
#### Spring Boot 和 Maven
```xml
<dependencies>
    <!-- ... 其他依赖元素 ... -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-security</artifactId>
    </dependency>
</dependencies>
```
#### 没有使用 Spring Boot 的 Maven
```xml
<properties>
    <spring-security.version>6.2.0-SNAPSHOT</spring-security.version>
</properties>

<dependencyManagement>
    <dependencies>
        <!-- ... 其他依赖节点 ... -->
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-bom</artifactId>
            <version>{spring-security-version}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
```
### 基本原理
本质是一个过滤器链：
```java
org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter
org.springframework.security.web.context.SecurityContextPersistenceFilter
org.springframework.security.web.header.HeaderWriterFilter
org.springframework.security.web.csrf.CsrfFilter
org.springframework.security.web.authentication.logout.LogoutFilter
org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter
org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter
org.springframework.security.web.authentication.ui.DefaultLogoutPageGeneratingFilter
org.springframework.security.web.savedrequest.RequestCacheAwareFilter
org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter
org.springframework.security.web.authentication.AnonymousAuthenticationFilter
org.springframework.security.web.session.SessionManagementFilter
org.springframework.security.web.access.ExceptionTranslationFilter
org.springframework.security.web.access.intercept.FilterSecurityInterceptor
```
主要的三个过滤器：
`FilterSecurityInterceptor`：是一个方法级的权限过滤器, 基本位于过滤链的最底部。

![FilterSecurityInterceptor](%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E4%B9%8BSpring%20Security.assets/C38b0edDEb1711034791318-4b839450-b27a-472f-a61a-00e3606394df.png)

`ExceptionTranslationFilter`：是个异常过滤器，用来处理在认证授权过程中抛出的异常。

![ExceptionTranslationFilter](%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E4%B9%8BSpring%20Security.assets/F9E78A11AB1711034804386-3ec8dbfc-8f07-4dc7-8119-b4630cb3b3ce.png)

`UsernamePasswordAuthenticationFilter` ：对/login 的 POST 请求做拦截，校验表单中用户名，密码。

![UsernamePasswordAuthenticationFilter](%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E4%B9%8BSpring%20Security.assets/287e656c211711034807997-ada2495c-fa0a-4f21-8008-452ce0675f45.png)

### UserDetailsService 接口

- 当什么也没有配置的时候，账号和密码是由 Spring Security 定义生成的。而在实际项目中账号和密码都是从数据库中查询出来的。 所以我们要通过自定义逻辑控制认证逻辑。
- 如果需要自定义逻辑时，只需要实现 UserDetailsService 接口即可。接口定义如下：

![aa2c45CDD71706802405020](%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E4%B9%8BSpring%20Security.assets/aa2c45CDD71706802405020-a58103b3-5190-4f4d-a382-37ddfd7e20c1.png)

返回值 UserDetails
这个类是系统默认的用户“主体”，我们只需要使用 User 这个实体类即可！

```java
// 表示获取登录用户所有权限
Collection<? extends GrantedAuthority> getAuthorities();

// 表示获取密码
String getPassword();

// 表示获取用户名
String getUsername();

// 表示判断账户是否过期
boolean isAccountNonExpired();

// 表示判断账户是否被锁定
boolean isAccountNonLocked();

// 表示凭证{密码}是否过期
boolean isCredentialsNonExpired();

// 表示当前用户是否可用
boolean isEnabled();
```
![809bBEbC851706802592723](%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E4%B9%8BSpring%20Security.assets/809bBEbC851706802592723-4599e3c9-52c8-470c-a8bd-faa9ffc4a745.png)

方法参数 username：表示用户名。此值是客户端表单传递过来的数据。默认情况下必须叫 username，否则无法接收。
但可以在配置类中通过以下方法修改：

![image](%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E4%B9%8BSpring%20Security.assets/FbaE5DB92b1706803688705-d8b19cdf-1ee9-4282-9327-4725674d2c3b.png)

### PasswordEncoder 接口
```java
// 表示把参数按照特定的解析规则进行解析
String encode(CharSequence rawPassword);

// 表示验证从存储中获取的编码密码与编码后提交的原始密码是否匹配。如果密码匹配，则返回 true；如果不匹配，则返回 false。第一个参数表示需要被解析的密码。第二个参数表示存储的密码。
boolean matches(CharSequence rawPassword, String encodedPassword);

// 表示如果解析的密码能够再次进行解析且达到更安全的结果则返回 true，否则返回false。默认返回 false。
default boolean upgradeEncoding(String encodedPassword) {
return false;
}
```
接口实现类：

![e6da9DdfF51706802715081](%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E4%B9%8BSpring%20Security.assets/e6da9DdfF51706802715081-12d2a7e5-1236-4927-9457-e6906b97e084.png)

BCryptPasswordEncoder 是 Spring Security 官方推荐的密码解析器，平时多使用这个解析器。
BCryptPasswordEncoder 是对 bcrypt 强散列方法的具体实现。是基于 Hash 算法实现的单向加密。可以通过 strength 控制加密强度，默认 10.
方法使用：

```java
@Test
public void test01(){
    // 创建密码解析
    BCryptPasswordEncoder bCryptPasswordEncoder = new BCryptPasswordEncoder();
    // 对密码进行加密
    String atguigu = bCryptPasswordEncoder.encode("atguigu");
    // 打印加密之后的数据
    System.out.println("加密之后数据：\t"+atguigu);  
    //判断原字符加密后和加密之前是否匹配
    boolean result = bCryptPasswordEncoder.matches("atguigu", atguigu);
    // 打印比较结果
    System.out.println("比较结果：\t"+result);
}
```
### 配置类实现WebSecurityConfigurerAdapter类
```java
@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
       auth.userDetailsService(userDetailsService).passwordEncoder(password());
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
//        http.formLogin()
//                .usernameParameter("loginAcct")     // 获取登录用户名
//                .passwordParameter("userpswd");     // 获取登录密码

        // 退出
        http.logout().logoutUrl("/logout").logoutSuccessUrl("/test/hello").permitAll();
        // 配置没有权限访问跳转自定义页面
        http.exceptionHandling().accessDeniedPage("/unauth.html");
        http.formLogin()   // 自定义自己编写的登录页面
                .loginPage("/login.html")   // 登录页面设置
                .loginProcessingUrl("/user/login")     // 登录访问路径
//                .defaultSuccessUrl("/test/index")   // 登录成功之后，跳转路径
                .defaultSuccessUrl("/success.html")
                .permitAll()
                .and().authorizeRequests()
                .antMatchers("/", "/test/hello", "/user/login").permitAll()    // 设置哪些路径可以直接访问，不需要认证
                // 当前登录用户，只有具有admins权限才没有访问这个路径
                // 1. hasAuthority()方法，如果当前的主体具有指定的权限，则返回 true,否则返回 false
//                .antMatchers("/test/index").hasAuthority("admins")
                // 2. hasAnyAuthority()方法，如果当前的主体有任何提供的角色的话，返回true.
                .antMatchers("/test/index")
                .hasAnyAuthority("admins", "manager")   // 需要用户待用admins或manager全写
                // 3. hasRole()方法，注意配置文件中不需要添加“ROLE_”，因为底层代码会自动添加与之进行匹配。
                .antMatchers("/test/index").hasRole("sale")
                .antMatchers("/findAll").hasRole("管理员")
                .antMatchers("/find").hasAnyAuthority("menu:system")
                .anyRequest()   // 其他请求
                .authenticated()    //需要认证
                .and().csrf().disable();    // 关闭csrf防护
        http.rememberMe().
                tokenRepository(persistentTokenRepository())
                .tokenValiditySeconds(60)   // 设置有效时长，单位秒
                .userDetailsService(userDetailsService);
    }	
}

```
### CSRF

- 跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。跟跨网站脚本(XSS)相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。
- 跨站请求攻击，简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去运行。这利用了 web 中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。
- 从 Spring Security 4.0 开始，**默认情况下会启用CSRF 保护**，以防止 CSRF 攻击应用程序，Spring Security CSRF **会针对 PATCH，POST，PUT 和DELETE 方法进行防护**。
### SpringSecurity 微服务权限方案

1. 如果是基于 Session，那么 Spring-security 会对 cookie 里的 sessionid 进行解析，找到服务器存储的 session 信息，然后判断当前用户是否符合请求的要求。
2. 如果是 token，则是解析出 token，然后将当前请求加入到 Spring-security 管理的权限信息中去。

![过程](%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E4%B9%8BSpring%20Security.assets/C0FaDfdDAA1711036428762-f5cbfac2-3a98-4238-96d9-cb4985d4419a.png)

如果系统的模块众多，每个模块都需要进行授权与认证，所以我们选择基于 token 的形式进行授权与认证，用户根据用户名密码认证成功，然后获取当前用户角色的一系列权限 值，并以用户名为 key，权限列表为 value 的形式存入 redis 缓存中，根据用户名相关信息生成 token 返回，浏览器将 token 记录到 cookie 中，每次调用 api 接口都默认将 token 携带到 header 请求头中，Spring-security 解析 header 头获取 token 信息，解析 token 获取当前用户名，根据用户名就可以从 redis 中获取权限列表，这样 Spring-security 就能够判断当前请求是否有权限访问

### 访问令牌JWT
![JWT](%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E4%B9%8BSpring%20Security.assets/Be47C62fbA1711036511382-98c8f918-b082-4ae4-9a4c-c5d8f3e141b4.png)
### SpringSecurity 原理总结
#### SpringSecurity 的过滤器介绍

SpringSecurity 采用的是责任链的设计模式，它有一条很长的过滤器链。现在对这条过滤器链的 15 个过滤器进行说明:

1. `WebAsyncManagerIntegrationFilter`：将 Security 上下文与 Spring Web 中用于处理异步请求映射的 WebAsyncManager 进行集成。
2. `SecurityContextPersistenceFilter`：在每次请求处理之前将该请求相关的安全上下文信息加载到 SecurityContextHolder 中，然后在该次请求处理完成之后，将 SecurityContextHolder 中关于这次请求的信息存储到一个“仓储”中，然后将 SecurityContextHolder 中的信息清除，例如在 Session 中维护一个用户的安全信息就是这个过滤器处理的。
3. `HeaderWriterFilter`：用于将头信息加入响应中。
4. `CsrfFilter`：用于处理跨站请求伪造。
5. `LogoutFilter`：用于处理退出登录。
6. `UsernamePasswordAuthenticationFilter`：用于处理基于表单的登录请求，从表单中获取用户名和密码。默认情况下处理来自 `/login` 的请求。从表单中获取用户名和密码时，默认使用的表单 name 值为 `username` 和 `password`，这两个值可以通过设置这个过滤器的 `usernameParameter` 和 `passwordParameter` 两个参数的值进行修改。
7. `DefaultLoginPageGeneratingFilter`：如果没有配置登录页面，那系统初始化时就会配置这个过滤器，并且用于在需要进行登录时生成一个登录表单页面。
8. `BasicAuthenticationFilter`：检测和处理 http basic 认证。
9. `RequestCacheAwareFilter`：用来处理请求的缓存。
10. `SecurityContextHolderAwareRequestFilter`：主要是包装请求对象 request。
11. `AnonymousAuthenticationFilter`：检测 SecurityContextHolder 中是否存在 Authentication 对象，如果不存在为其提供一个匿名 Authentication。
12. `SessionManagementFilter`：管理 session 的过滤器。
13. `ExceptionTranslationFilter`：处理 AccessDeniedException 和 AuthenticationException 异常。
14. `FilterSecurityInterceptor`：可以看做过滤器链的出口。
15. `RememberMeAuthenticationFilter`：当用户没有登录而直接访问资源时, 从 cookie 里找出用户的信息, 如果 Spring Security 能够识别出用户提供的 remember me cookie, 用户将不必填写用户名和密码, 而是直接登录进入系统，该过滤器默认不开启。

#### SpringSecurity 基本流程

Spring Security 采取过滤链实现认证与授权，只有当前过滤器通过，才能进入下一个过滤器：

![image-20240422214525224](%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E4%B9%8BSpring%20Security.assets/image-20240422214525224.png)

**绿色部分**是认证过滤器，需要我们自己配置，可以配置多个认证过滤器。认证过滤器可以使用 Spring Security 提供的认证过滤器，也可以自定义过滤器（例如：短信验证）。认证过滤器要在 configure(HttpSecurity http)方法中配置，没有配置不生效。下面会重点介绍以下三个过滤器：

`UsernamePasswordAuthenticationFilter` 过滤器：该过滤器会拦截前端提交的 POST 方式的登录表单请求，并进行身份认证。

`ExceptionTranslationFilter` 过滤器：该过滤器不需要我们配置，对于前端提交的请求会直接放行，捕获后续抛出的异常并进行处理（例如：权限访问限制）。

`FilterSecurityInterceptor` 过滤器：该过滤器是过滤器链的最后一个过滤器，根据资源权限配置来判断当前请求是否有权限访问对应的资源。如果访问受限会抛出相关异常，并由 ExceptionTranslationFilter 过滤器进行捕获和处理。

#### SpringSecurity 认证流程

认证流程是在 `UsernamePasswordAuthenticationFilter` 过滤器中处理的，具体流程如下所示：

![23-认证流程](%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E4%B9%8BSpring%20Security.assets/23-%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B.jpg)

##### UsernamePasswordAuthenticationFilter 源码

当前端提交的是一个 POST 方式的登录表单请求，就会被该过滤器拦截，并进行身份认证。该过滤器的 doFilter() 方法实现在其抽象父类`AbstractAuthenticationProcessingFilter` 中，查看相关源码：

![image-20240422215055748](%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E4%B9%8BSpring%20Security.assets/image-20240422215055748.png)

![image-20240422215122699](%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E4%B9%8BSpring%20Security.assets/image-20240422215122699.png)

![image-20240422215214361](%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E4%B9%8BSpring%20Security.assets/image-20240422215152167.png)

![image-20240422215214361](%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E4%B9%8BSpring%20Security.assets/image-20240422215214361.png)

![image-20240422215231178](%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E4%B9%8BSpring%20Security.assets/image-20240422215231178.png)

上述的 第二 过程调用了 `UsernamePasswordAuthenticationFilter` 的 `attemptAuthentication() `方法，源码如下：

![image-20240422215359136](%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E4%B9%8BSpring%20Security.assets/image-20240422215359136.png)

![image-20240422215419826](%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E4%B9%8BSpring%20Security.assets/image-20240422215419826.png)

![image-20240422215434883](%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E4%B9%8BSpring%20Security.assets/image-20240422215434883.png)

上述的(3)过程创建的 `UsernamePasswordAuthenticationToken` 是 `Authentication` 接口的实现类，该类有两个构造器，一个用于封装前端请求传入的未认证的用户信息，一个用于封装认证成功后的用户信息：

![image-20240422215532309](%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E4%B9%8BSpring%20Security.assets/image-20240422215532309.png)

`Authentication` 接口的实现类用于存储用户认证信息，查看该接口具体定义：

![image-20240422215608321](%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E4%B9%8BSpring%20Security.assets/image-20240422215608321.png)

##### ProviderManager 源码

上述过程中，`UsernamePasswordAuthenticationFilter` 过滤器的 `attemptAuthentication()` 方法的(5)过程将未认证的 Authentication 对象传入 ProviderManager 类的 authenticate() 方法进行身份认证。

ProviderManager 是 AuthenticationManager 接口的实现类，该接口是认证相关的核心接口，也是认证的入口。在实际开发中，我们可能有多种不同的认证方式，例如：用户名+ 密码、邮箱+密码、手机号+验证码等，而这些认证方式的入口始终只有一个，那就是 AuthenticationManager。在该接口的常用实现类 ProviderManager 内部会维护一个 `List<AuthenticationProvider>` 列表，存放多种认证方式，实际上这是委托者模式(Delegate)的应用。每种认证方式对应着一个 AuthenticationProvider， AuthenticationManager 根据认证方式的不同（根据传入的 Authentication 类型判断）委托对应的 AuthenticationProvider 进行用户认证。

![image-20240422215814055](%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E4%B9%8BSpring%20Security.assets/image-20240422215814055.png)

![image-20240422215855846](%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E4%B9%8BSpring%20Security.assets/image-20240422215855846.png)

![image-20240422220007046](%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E4%B9%8BSpring%20Security.assets/image-20240422220007046.png)

![image-20240422220029162](%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E4%B9%8BSpring%20Security.assets/image-20240422220029162.png)

上述认证成功之后的(6)过程，调用 `CredentialsContainer` 接口定义的 `eraseCredentials()` 方法去除敏感信息。查看`UsernamePasswordAuthenticationToken` 实现的 `eraseCredentials()` 方法，该方法实现在其父类中：

![image-20240422220125987](%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E4%B9%8BSpring%20Security.assets/image-20240422220125987.png)

##### 认证成功/失败处理

上述过程就是认证流程的最核心部分，接下来重新回到 `UsernamePasswordAuthenticationFilter` 过滤器的 `doFilter()` 方法，查看认证成功/失败的处理：

![image-20240422220235323](%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E4%B9%8BSpring%20Security.assets/image-20240422220235323.png)

查看 `successfulAuthentication()` 和 `unsuccessfulAuthentication()` 方法源码

![image-20240422220550530](%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E4%B9%8BSpring%20Security.assets/image-20240422220550530.png)

![24-认证流程中各核心类和接口的关系](%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E4%B9%8BSpring%20Security.assets/24-%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B%E4%B8%AD%E5%90%84%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%85%B3%E7%B3%BB%E5%9B%BE.jpg)

#### SpringSecurity 权限访问流程

上一个部分通过源码的方式介绍了认证流程，下面介绍权限访问流程，主要是对 `ExceptionTranslationFilter` 过滤器和 `FilterSecurityInterceptor` 过滤器进行介绍。

##### ExceptionTranslationFilter 过滤器

该过滤器是用于处理异常的，不需要我们配置，对于前端提交的请求会直接放行，捕获后续抛出的异常并进行处理（例如：权限访问限制）。具体源码如下：

![image-20240422220805549](%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E4%B9%8BSpring%20Security.assets/image-20240422220805549.png)

##### FilterSecurityInterceptor 过滤器

`FilterSecurityInterceptor` 是过滤器链的最后一个过滤器，该过滤器是过滤器链的最后一个过滤器，根据资源权限配置来判断当前请求是否有权限访问对应的资源。如果访问受限会抛出相关异常，最终所抛出的异常会由前一个过滤器 `ExceptionTranslationFilter` 进行捕获和处理。具体源码如下：

![image-20240422220933151](%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E4%B9%8BSpring%20Security.assets/image-20240422220933151.png)

需要注意，Spring Security 的过滤器链是配置在 SpringMVC 的核心组件 DispatcherServlet 运行之前。也就是说，请求通过 Spring Security 的所有过滤器， 不意味着能够正常访问资源，该请求还需要通过 SpringMVC 的拦截器链。

#### SpringSecurity 请求间共享认证信息

一般认证成功后的用户信息是通过 Session 在多个请求之间共享，那么 Spring Security 中是如何实现将已认证的用户信息对象 Authentication 与 Session 绑定的进行具体分析。

![image-20240422221118815](%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E4%B9%8BSpring%20Security.assets/image-20240422221118815.png)

- 在前面讲解认证成功的处理方法 `successfulAuthentication()` 时，有以下代码：

    ![image-20240422221210869](%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E4%B9%8BSpring%20Security.assets/image-20240422221210869.png)

- 查看 SecurityContext 接口及其实现类 `SecurityContextImpl`， 该类其实就是对 Authentication 的封装

    ![image-20240422221347113](%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E4%B9%8BSpring%20Security.assets/image-20240422221347113.png)

- 查看  `SecurityContextHolder` 类 ， 该类其实是对 ThreadLocal 的 封 装 ， 存储 SecurityContext 对象

    ![image-20240422221423767](%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E4%B9%8BSpring%20Security.assets/image-20240422221423767.png)

    ![image-20240422221444667](%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E4%B9%8BSpring%20Security.assets/image-20240422221444667.png)

![image-20240422221511108](%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E4%B9%8BSpring%20Security.assets/image-20240422221511108.png)

##### SecurityContextPersistenceFilter 过滤器

前面提到过，在 `UsernamePasswordAuthenticationFilter` 过滤器认证成功之后，会在认证成功的处理方法中将已认证的用户信息对象 Authentication 封装进 SecurityContext，并存入 SecurityContextHolder。

之后，响应会通过 `SecurityContextPersistenceFilter` 过滤器，该过滤器的位置在所有过滤器的最前面，请求到来先进它，响应返回最后一个通过它，所以在该过滤器中处理已认证的用户信息对象 Authentication 与 Session 绑定。

认证成功的响应通过 `SecurityContextPersistenceFilter` 过滤器时，会从 `SecurityContextHolder` 中取出封装了已认证用户信息对象 Authentication 的 SecurityContext，放进 Session 中。当请求再次到来时，请求首先经过该过滤器，该过滤器会判断当前请求的 Session 是否存有 SecurityContext 对象，如果有则将该对象取出再次放入 `SecurityContextHolder` 中，之后该请求所在的线程获得认证用户信息，后续的资源访问不需要进行身份认证；当响应再次返回时，该过滤器同样从 `SecurityContextHolder` 取出 SecurityContext 对象，放入 Session 中。具体源码如下：

![image-20240422221927771](%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E4%B9%8BSpring%20Security.assets/image-20240422221927771.png)

![image-20240422222009702](%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E4%B9%8BSpring%20Security.assets/image-20240422222009702.png)

## 参考资料

[Spring Security中文文档](https://www.springcloud.cc/spring-security.html)

[Spring Security 中文文档 :: Spring Security Reference (springdoc.cn)](https://springdoc.cn/spring-security/)
